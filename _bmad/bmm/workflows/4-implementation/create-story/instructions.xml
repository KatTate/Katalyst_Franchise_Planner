<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language} and generate all documents in {document_output_language}</critical>

  <critical>üî• CRITICAL MISSION: You are creating the ULTIMATE story context engine that prevents LLM developer mistakes, omissions or
    disasters! üî•</critical>
  <critical>Your purpose is NOT to copy from epics ‚Äî it's to create a comprehensive, optimized story file that gives the DEV agent
    EVERYTHING needed for flawless implementation. The story file is an intent-and-constraint document, NOT an implementation script.</critical>
  <critical>COMMON LLM MISTAKES TO PREVENT: reinventing wheels, wrong libraries, wrong file locations, breaking regressions, ignoring UX,
    vague implementations, lying about completion, not learning from past work</critical>
  <critical>The quality bar: Could a competent developer (or AI agent) read the acceptance criteria and dev notes and build the right
    thing without a task list? If yes, the story is complete. If no, the acceptance criteria or dev notes are missing something.</critical>
  <critical>DO NOT write a Tasks/Subtasks section. The dev agent creates its own implementation plan from the acceptance criteria and
    dev notes. Pre-writing implementation steps removes the agent's ability to plan effectively.</critical>
  <critical>OUTPUT CONSTRAINT: This workflow produces ONE markdown file as output.
    You must NOT:
    - Write, modify, or create any application source code files
    - Install packages or run build/test commands
    - Create components, pages, routes, database schemas, or API endpoints
    - Use any file-writing tools except to save the story document to {{default_output_file}}
    If at any point you begin analyzing code with the intent to CHANGE it rather than
    UNDERSTAND it for story context, STOP. That is the Dev Story workflow's job.</critical>
  <critical>üö® EXHAUSTIVE ANALYSIS REQUIRED: You must thoroughly analyze ALL artifacts to extract critical context ‚Äî do NOT be lazy or skim!
    This is the most important function in the entire development process!</critical>
  <critical>üî¨ UTILIZE SUBPROCESSES AND SUBAGENTS: Use research subagents, subprocesses or parallel processing if available to thoroughly
    analyze different artifacts simultaneously and thoroughly</critical>
  <critical>‚ùì SAVE QUESTIONS: If you think of questions or clarifications during analysis, save them for the end after the complete story is
    written</critical>
  <critical>üéØ ZERO USER INTERVENTION: Process should be fully automated except for initial epic/story selection or missing documents</critical>
  <critical>üí° REPLIT TIP: For best results, run this workflow in a fresh chat to maximize available context for artifact analysis</critical>

  <step n="1" goal="Determine target story">
    <check if="user provided the story identifier ‚Äî a path, epic-story number (e.g. 2-4, 1.6, epic 1 story 5), or story key">
      <action>Parse user-provided input: extract epic_num, story_num, story_title from format like "1-2-user-auth"</action>
      <action>Set {{epic_num}}, {{story_num}}, {{story_key}} from user input</action>
      <action>GOTO step 2</action>
    </check>

    <action>Check if {{sprint_status}} file exists for auto discover</action>
    <check if="sprint status file does NOT exist">
      <output>üö´ No sprint status file found and no story specified</output>
      <output>
        **Required Options:**
        1. Run `sprint-planning` to initialize sprint tracking (recommended)
        2. Provide specific epic-story number to create (e.g., "1-2-user-auth")
        3. Provide path to story documents if sprint status doesn't exist yet
      </output>
      <ask>Choose option [1], provide epic-story number, path to story docs, or [q] to quit:</ask>

      <check if="user chooses 'q'">
        <action>HALT - No work needed</action>
      </check>

      <check if="user chooses '1'">
        <output>Run sprint-planning workflow first to create sprint-status.yaml</output>
        <action>HALT - User needs to run sprint-planning</action>
      </check>

      <check if="user provides epic-story number">
        <action>Parse user input: extract epic_num, story_num, story_title</action>
        <action>Set {{epic_num}}, {{story_num}}, {{story_key}} from user input</action>
        <action>GOTO step 2</action>
      </check>

      <check if="user provides story docs path">
        <action>Use user-provided path for story documents</action>
        <action>GOTO step 2</action>
      </check>
    </check>

    <!-- Auto-discover from sprint status only if no user input -->
    <check if="no user input provided">
      <critical>MUST read COMPLETE {sprint_status} file from start to end to preserve order</critical>
      <action>Load the FULL file: {{sprint_status}}</action>
      <action>Read ALL lines from beginning to end - do not skip any content</action>
      <action>Parse the development_status section completely</action>

      <action>Find the FIRST story (by reading in order from top to bottom) where:
        - Key matches pattern: number-number-name (e.g., "1-2-user-auth")
        - NOT an epic key (epic-X) or retrospective (epic-X-retrospective)
        - Status value equals "backlog"
      </action>

      <check if="no backlog story found">
        <output>üìã No backlog stories found in sprint-status.yaml

          All stories are either already created, in progress, or done.

          **Options:**
          1. Run sprint-planning to refresh story tracking
          2. Load PM agent and run correct-course to add more stories
          3. Check if current sprint is complete and run retrospective
        </output>
        <action>HALT</action>
      </check>

      <action>Extract from found story key (e.g., "1-2-user-authentication"):
        - epic_num: first number before dash (e.g., "1")
        - story_num: second number after first dash (e.g., "2")
        - story_title: remainder after second dash (e.g., "user-authentication")
      </action>
      <action>Set {{story_id}} = "{{epic_num}}.{{story_num}}"</action>
      <action>Store story_key for later use (e.g., "1-2-user-authentication")</action>

      <!-- Mark epic as in-progress if this is first story -->
      <action>Check if this is the first story in epic {{epic_num}} by looking for {{epic_num}}-1-* pattern</action>
      <check if="this is first story in epic {{epic_num}}">
        <action>Load {{sprint_status}} and check epic-{{epic_num}} status</action>
        <action>If epic status is "backlog" ‚Üí update to "in-progress"</action>
        <action>If epic status is "contexted" (legacy status) ‚Üí update to "in-progress" (backward compatibility)</action>
        <action>If epic status is "in-progress" ‚Üí no change needed</action>
        <check if="epic status is 'done'">
          <output>üö´ ERROR: Cannot create story in completed epic</output>
          <output>Epic {{epic_num}} is marked as 'done'. All stories are complete.</output>
          <output>If you need to add more work, either:</output>
          <output>1. Manually change epic status back to 'in-progress' in sprint-status.yaml</output>
          <output>2. Create a new epic for additional work</output>
          <action>HALT - Cannot proceed</action>
        </check>
        <check if="epic status is not one of: backlog, contexted, in-progress, done">
          <output>üö´ ERROR: Invalid epic status '{{epic_status}}'</output>
          <output>Epic {{epic_num}} has invalid status. Expected: backlog, in-progress, or done</output>
          <output>Please fix sprint-status.yaml manually or run sprint-planning to regenerate</output>
          <action>HALT - Cannot proceed</action>
        </check>
        <output>üìä Epic {{epic_num}} status updated to in-progress</output>
      </check>

      <action>GOTO step 2</action>
    </check>
  </step>

  <step n="2" goal="Load and analyze core artifacts for story context">
    <critical>üî¨ EXHAUSTIVE ARTIFACT ANALYSIS ‚Äî This is where you prevent future developer mistakes!</critical>

    <invoke-protocol name="discover_inputs" />
    <note>Available content: {epics_content}, {prd_content}, {architecture_content}, {ux_content}, {project_context}</note>

    <!-- Extract story foundation from epics -->
    <action>From {epics_content}, extract Epic {{epic_num}} complete context:
      - Epic objectives and business value
      - ALL stories in this epic for cross-story awareness
      - Our specific story's user story statement, acceptance criteria, technical requirements
      - Dependencies on other stories/epics
      - Source hints pointing to original documents
    </action>

    <!-- UX/UI requirements extraction for user-facing stories -->
    <check if="story's 'As a...' role is an end user (not a developer) AND {ux_content} is available">
      <action>From {ux_content}, extract UI/UX requirements relevant to this story:
        - Screens, pages, or components the user interacts with
        - Form fields, validation rules, and error states
        - Navigation flows and how the user reaches this feature
        - Loading states, empty states, and error displays
        - Role-based UI visibility rules
        - Any wireframes, mockups, or design specifications
      </action>
    </check>

    <!-- Previous story intelligence -->
    <check if="story_num > 1">
      <action>Load previous story file: {{story_dir}}/{{epic_num}}-{{previous_story_num}}-*.md</action>
      <action>Extract actionable intelligence:
        - Dev notes and learnings from previous story
        - Review feedback and corrections needed
        - Files created/modified and their patterns
        - Problems encountered and solutions found
        - Code patterns established
      </action>
    </check>

    <!-- Git intelligence for recent work patterns -->
    <check if="previous story exists AND git repository detected">
      <action>Get last 5 commit titles to understand recent work patterns</action>
      <action>Analyze 1-5 most recent commits for relevance to current story:
        - Files created/modified
        - Code patterns and conventions used
        - Library dependencies added/changed
        - Architecture decisions implemented
        - Testing approaches used
      </action>
      <action>Extract actionable insights for current story implementation</action>
    </check>
  </step>

  <step n="3" goal="Architecture analysis for developer guardrails">
    <critical>üèóÔ∏è ARCHITECTURE INTELLIGENCE ‚Äî Extract everything the developer MUST follow!</critical>

    <action>Systematically analyze {architecture_content} for story-relevant requirements:</action>

    <!-- Load architecture - single file or sharded -->
    <check if="architecture file is single file">
      <action>Load complete {architecture_content}</action>
    </check>
    <check if="architecture is sharded to folder">
      <action>Load architecture index and scan all architecture files</action>
    </check>

    <action>For each architecture section, determine if relevant to this story:
      - Technical Stack: Languages, frameworks, libraries with versions
      - Code Structure: Folder organization, naming conventions, file patterns
      - API Patterns: Service structure, endpoint patterns, data contracts
      - Database Schemas: Tables, relationships, constraints relevant to story
      - Security Requirements: Authentication patterns, authorization rules
      - Performance Requirements: Caching strategies, optimization patterns
      - Testing Standards: Testing frameworks, coverage expectations, test patterns
      - Deployment Patterns: Environment configurations, build processes
      - Integration Patterns: External service integrations, data flows
    </action>
    <action>Extract any story-specific requirements that the developer MUST follow</action>
    <action>Identify any architectural decisions that override previous patterns</action>
  </step>

  <step n="4" goal="Research latest technical specifics">
    <action>Identify specific libraries, APIs, or frameworks relevant to this story from architecture analysis</action>
    <action>For each critical technology, research latest stable version and key information:
      - Breaking changes or security updates
      - Best practices for current version
      - API documentation specifics needed for implementation
    </action>
  </step>

  <step n="5" goal="Create the story context document">
    <critical>The story file is an intent-and-constraint document. It tells the dev agent WHAT to build and WHAT
      constraints to follow ‚Äî not HOW to implement step by step.</critical>

    <action>Initialize from template: {{default_output_file}}</action>

    <!-- Story and Acceptance Criteria -->
    <action>Write user story statement from epics analysis</action>
    <action>Write acceptance criteria that are specific and testable.
      - File paths ARE allowed in AC when they represent verifiable outcomes (e.g., "types are exported from shared/schema.ts")
      - Do NOT use AC to dictate implementation sequence
      - CRITICAL: If the story's "As a..." role is an END USER (not a developer), ACs MUST describe
        what the user SEES and DOES on screen ‚Äî pages, forms, buttons, tables, messages, navigation.
        NEVER use HTTP methods (GET, POST, PUT, DELETE) or endpoint paths (/api/...) in ACs for
        end-user stories. API details belong ONLY in Dev Notes, not in acceptance criteria.
        Example BAD AC: "When I submit POST /api/invitations with email and role..."
        Example GOOD AC: "When I fill out the invitation form and click Send..."
    </action>

    <!-- Dev Notes ‚Äî the guardrails section -->
    <action>Write "Architecture Patterns to Follow" ‚Äî key conventions the implementation MUST follow:
      - Naming conventions, code organization patterns
      - Database patterns, API patterns
      - Framework-specific patterns from architecture doc
    </action>

    <action>Write "Anti-Patterns and Hard Constraints" ‚Äî things the dev agent MUST NOT do:
      - Wrong libraries or approaches to avoid
      - Files that must not be modified
      - Common mistakes for this type of work
      - Existing code that must not be duplicated
    </action>

    <action>Write "Gotchas and Integration Warnings" ‚Äî non-obvious traps:
      - Dependencies on system state or other stories
      - Edge cases or surprising behaviors
      - Template code that needs replacing vs preserving
    </action>

    <action>Write "File Change Summary" table ‚Äî directional guidance:
      - Which files will be created, modified, or replaced
      - Brief context for each (not step-by-step instructions)
      - CRITICAL: If the story's "As a..." role is an end user, the File Change Summary MUST include
        frontend/UI files (pages, components, forms). A user-facing story without frontend files in
        the change summary is INCOMPLETE. The dev agent treats this table as scope ‚Äî if UI files are
        missing, the UI will not be built.
    </action>

    <action>Write "UI/UX Deliverables" section (REQUIRED for end-user stories, skip for developer stories):
      - List the screens, pages, or components the user will interact with
      - Describe key UI elements: forms, tables, buttons, navigation, error states, success states
      - Reference UX/design documents if they exist
      - This section ensures the dev agent knows a UI is expected and what it should contain
    </action>

    <action>Write "Testing Expectations" (brief, directional ‚Äî not a test plan):
      - What type of testing is expected for this story (unit tests, integration tests, visual verification, etc.)
      - If the project has an established test framework, note which one and where existing tests live
      - If specific ACs should have automated test coverage, note which ones
      - This section helps the dev agent prioritize testing effort appropriately
    </action>

    <action>Write "Dependencies and Environment Variables":
      - Packages to install (and packages already present ‚Äî DO NOT reinstall)
      - Environment variables needed
      - External services or configuration
    </action>

    <action>Write "References" ‚Äî cite source documents for all technical details</action>

    <!-- Dev Agent Record -->
    <action>Set story Status to "ready-for-dev"</action>
  </step>

  <step n="6" goal="Validate story quality and update sprint status">
    <critical>üö® THIS STEP IS MANDATORY ‚Äî Do NOT skip validation or sprint status updates!</critical>

    <!-- Quality validation -->
    <action>Apply the quality bar test: Could a competent developer or AI agent read this story's acceptance criteria
      and dev notes and build the right thing without a task list?</action>
    <action>If NO ‚Äî identify what's missing and fix the acceptance criteria or dev notes before proceeding</action>
    <action>If YES ‚Äî the story is complete</action>

    <invoke-task>Validate against checklist at {installed_path}/checklist.md using _bmad/core/tasks/validate-workflow.xml</invoke-task>
    <action>Save story document</action>
    <action>Set {{story_quality_validated}} = "yes"</action>

    <!-- Update sprint status -->
    <check if="sprint status file exists">
      <action>Update {{sprint_status}}</action>
      <action>Load the FULL file and read all development_status entries</action>
      <action>Find development_status key matching {{story_key}}</action>
      <action>Update development_status[{{story_key}}] = "ready-for-dev"</action>
      <action>Save file, preserving ALL comments and structure</action>
      <action>Set {{sprint_status_updated}} = "yes"</action>
    </check>
    <check if="sprint status file does NOT exist">
      <action>Set {{sprint_status_updated}} = "N/A"</action>
    </check>

    <action>Report completion and present next steps menu</action>
    <output>**üéØ Story Context Created, {user_name}!**

      **Story Details:**
      - Story ID: {{story_id}}
      - Story Key: {{story_key}}
      - File: {{default_output_file}}
      - Status: ready-for-dev

      ---

      **Next Steps:**

      [A] Advanced Elicitation ‚Äî refine the story further
      [R] Adversarial Review ‚Äî critical review of the story (recommended)
      [P] Party Mode ‚Äî multi-agent review of the story
      [D] Done ‚Äî exit workflow

      ---

      Once you are satisfied with the story (ideally after **Adversarial Review** or **Party Mode**), start implementation in a FRESH CONTEXT for best results.

      When ready, start a NEW chat session and use one of these prompts:

      FOR IMPLEMENTATION:
      ```
      dev story {{default_output_file}}
      ```

      FOR TEST GENERATION:
      ```
      QA {{default_output_file}}
      ```

      ‚õî DO NOT execute these commands in this session. This workflow is COMPLETE.
      The above are instructions for the USER to copy into a fresh chat.
      A fresh context gives the dev agent maximum working memory for the build.
    </output>

    <ask>Select [A], [R], [P], [D], or share any feedback:</ask>

    <check if="user chooses A">
      <action>Read fully and follow: {project-root}/_bmad/core/workflows/advanced-elicitation/workflow.xml with current story content</action>
      <action>Process enhanced insights and ask user "Accept improvements? (y/n)"</action>
      <action>If yes, update story file. If no, keep original.</action>
      <action>Redisplay the next steps menu above</action>
    </check>

    <check if="user chooses R">
      <action>Load and follow adversarial review: {project-root}/_bmad/core/tasks/review-adversarial-general.xml against {{default_output_file}}</action>
      <action>Present findings with severity ratings</action>
      <action>Ask user which findings to address, update story file accordingly</action>
      <action>Redisplay the next steps menu above</action>
    </check>

    <check if="user chooses P">
      <action>Read fully and follow: {project-root}/_bmad/core/workflows/party-mode/workflow.md with current story content</action>
      <action>Process collaborative insights and ask user "Accept changes? (y/n)"</action>
      <action>If yes, update story file. If no, keep original.</action>
      <action>Redisplay the next steps menu above</action>
    </check>

    <check if="user chooses D">
      <output>**All done!** Your story is ready at:

        `{{default_output_file}}`

        When you're ready to implement in a fresh context:

        ```
        dev story {{default_output_file}}
        ```

        Or generate tests first:

        ```
        QA {{default_output_file}}
        ```
      </output>
    </check>
  </step>

</workflow>
