<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language} and language MUST be tailored to {user_skill_level}</critical>
  <critical>Generate all documents in {document_output_language}</critical>
  <critical>User skill level ({user_skill_level}) affects conversation style ONLY, not code quality.</critical>
  <critical>Execute ALL steps in exact order; do NOT skip steps. This workflow has 11 steps. You are NOT done until step 11 is complete.</critical>
  <critical>Absolutely DO NOT stop because of "milestones", "significant progress", or "session boundaries". Continue in a single execution
    until the story is COMPLETE (all ACs satisfied) UNLESS a HALT condition is triggered or the USER gives other instruction.</critical>
  <critical>STEP 8 IS THE MOST IMPORTANT STEP IN THIS WORKFLOW. Steps 1-7 are preparation.
    If you are running low on context, PRIORITIZE completing Step 8 (AC verification with evidence)
    over verbose implementation narration in Step 6. A story with verified ACs and brief implementation
    notes is better than a story with detailed implementation logs but skipped verification.</critical>
  <critical>Do NOT schedule a "next session" or request review pauses unless a HALT condition applies. Only Step 11 decides completion.</critical>
  <critical>REPLIT TIP: For best results, run this workflow in a fresh chat to maximize available context.</critical>

  <step n="1" goal="Load story file as authoritative context">
    <check if="{{story_file}} is provided">
      <action>Use {{story_file}} directly</action>
      <action>Read COMPLETE story file</action>
      <action>Extract story_key from filename or metadata</action>
      <goto anchor="context_loaded" />
    </check>

    <!-- Sprint-based story discovery -->
    <check if="{{sprint_status}} file exists">
      <critical>MUST read COMPLETE sprint-status.yaml file from start to end to preserve order</critical>
      <action>Load the FULL file: {{sprint_status}}</action>
      <action>Read ALL lines from beginning to end - do not skip any content</action>
      <action>Parse the development_status section completely to understand story order</action>

      <action>Find the FIRST story (by reading in order from top to bottom) where:
        - Key matches pattern: number-number-name (e.g., "1-2-user-auth")
        - NOT an epic key (epic-X) or retrospective (epic-X-retrospective)
        - Status value equals "ready-for-dev" or "in-progress"
      </action>

      <check if="no ready-for-dev or in-progress story found">
        <output>üìã No stories ready for development.

          **Options:**
          1. Say "create story" to create the next story from epics
          2. Specify a particular story file path to develop
        </output>
        <ask>What would you like to do?</ask>
        <action>HALT if user chooses to create story first</action>
      </check>
    </check>

    <!-- Non-sprint story discovery -->
    <check if="{{sprint_status}} file does NOT exist">
      <action>Search {story_dir} for story files with "ready-for-dev" status</action>
      <check if="no ready-for-dev stories found">
        <output>üìã No ready-for-dev stories found.

          **Options:**
          1. Say "create story" to create the next story from epics
          2. Specify which story file to develop
        </output>
        <ask>What would you like to do?</ask>
        <action>HALT if no story to work on</action>
      </check>
    </check>

    <action>Load the discovered story file completely</action>
    <action>Extract story_key from filename</action>

    <anchor id="context_loaded" />

    <action>Parse the story file sections: Story, Acceptance Criteria, Dev Notes, Dev Agent Record</action>
    <action>Treat Dev Notes as HARD CONSTRAINTS ‚Äî these are not suggestions, they are rules</action>
    <action>Treat Acceptance Criteria as the DEFINITION OF DONE ‚Äî every AC must be satisfied</action>
  </step>

  <step n="2" goal="Load project context">
    <critical>Load all available context to inform implementation</critical>

    <action>Load {project_context} for coding standards and project-wide patterns (if exists)</action>
    <action>Extract developer guidance from Dev Notes: architecture requirements, previous learnings, technical specifications</action>
    <action>Use enhanced story context to inform implementation decisions and approaches</action>

    <action>DEPENDENCY VERIFICATION: If this story's Dev Notes reference infrastructure,
      components, or hooks from a previous story:
      1. Identify each dependency (e.g., "reuse useColumnManager from Story 5.2")
      2. Load the ORIGINAL story file for that dependency
      3. Read the original story's acceptance criteria for that infrastructure
      4. Verify the dependency meets its ORIGINAL spec ‚Äî not just that it runs
      5. If the dependency is missing features specified in its original ACs, flag this
         BEFORE implementation. Either fix the dependency first or adjust the current
         story's approach.
      This prevents inheriting gaps from prior stories. "It works" is not the same as
      "it works as spec'd."
    </action>
    <output>‚úÖ **Context Loaded**
      Story and project context available for implementation
    </output>
  </step>

  <step n="3" goal="Detect review continuation">
    <critical>Determine if this is a fresh start or continuation after code review</critical>

    <action>Check story status and look for any review feedback appended to the story file</action>

    <check if="story status is 'in-progress' or story file contains review feedback from a previous code review">
      <action>Look for any review notes, action items, or feedback sections appended to the story file</action>
      <action>If review feedback exists with unresolved items, prioritize addressing those first</action>
      <output>‚èØÔ∏è **Resuming Implementation:** {{story_key}}
        Will address any pending review feedback before continuing.
      </output>
    </check>

    <check if="story status is 'ready-for-dev' and no prior review feedback exists">
      <output>üöÄ **Starting Implementation:** {{story_key}}</output>
    </check>
  </step>

  <step n="4" goal="Mark story in-progress and update sprint status">
    <action>Update story file Status to "in-progress"</action>

    <check if="{{sprint_status}} file exists">
      <action>Load the FULL file: {{sprint_status}}</action>
      <action>Read all development_status entries to find {{story_key}}</action>

      <check if="current status == 'ready-for-dev'">
        <action>Update development_status[{{story_key}}] = "in-progress"</action>
        <action>Save file, preserving ALL comments and structure</action>
        <output>üöÄ Starting work on story {{story_key}}
          Sprint status updated: ready-for-dev ‚Üí in-progress
        </output>
      </check>

      <check if="current status == 'in-progress'">
        <output>‚èØÔ∏è Resuming work on story {{story_key}}
          Story is already marked in-progress
        </output>
      </check>
    </check>

    <check if="{{sprint_status}} file does NOT exist">
      <output>‚ÑπÔ∏è No sprint status file ‚Äî tracking progress in story file only</output>
    </check>
  </step>

  <step n="5" goal="Plan implementation approach">
    <critical>Create your own implementation plan from the acceptance criteria and dev notes.
      Use the platform's native task management to track your work. Do NOT write a task list
      into the story file.</critical>

    <critical>Dev Notes constraints are LAW:
      - "Anti-Patterns and Hard Constraints" ‚Äî violations are bugs
      - "Architecture Patterns to Follow" ‚Äî deviations require justification
      - "File Change Summary" ‚Äî directional guidance, not rigid prescription
      - "Dependencies" ‚Äî install what's listed, do not reinstall what's already present
    </critical>

    <critical>USER-FACING STORY CHECK: Before planning, determine if this story is user-facing.
      If the story's "As a..." role is an end user (not a developer), the implementation plan
      MUST include UI work ‚Äî pages, forms, tables, components. An end-user story implemented
      as API-only (without a usable interface) is INCOMPLETE regardless of whether all API
      acceptance criteria pass. If the story's Dev Notes include a "UI/UX Deliverables" section,
      those deliverables are REQUIRED outputs.</critical>

    <action>Create an implementation plan based on acceptance criteria and dev notes</action>
    <action>Break the plan into discrete tasks in the platform's task management</action>

    <action if="new dependencies required beyond what's listed in Dev Notes">ASK user for approval before adding</action>
    <action if="acceptance criteria are ambiguous or contradictory">ASK user to clarify before proceeding</action>
  </step>

  <step n="6" goal="Implement the plan">
    <critical>Execute your implementation plan task by task. Do NOT skip ahead to later steps
      until the implementation work is substantially complete.</critical>

    <action>Implement each task in your plan, following all Dev Notes constraints</action>
    <action>Handle error conditions and edge cases as specified in dev notes</action>
    <action>Ensure code follows architecture patterns and coding standards from Dev Notes and project context</action>

    <action if="implementation conflicts with Dev Notes constraints">HALT and explain the conflict</action>
    <action if="3 consecutive implementation failures occur">HALT and request guidance</action>
    <action if="required configuration is missing">HALT: "Cannot proceed without necessary configuration"</action>

    <critical>Execute continuously without unnecessary pauses. Do NOT propose to stop for review
      until you have completed implementation AND reached Step 8.</critical>
  </step>

  <step n="7" goal="Test implementation">
    <critical>This is a separate step from implementation. Do NOT skip this step.</critical>

    <action>Test appropriately for the task type:
      - Schema, config, and infrastructure tasks: verify by running them
      - Business logic and API endpoints: write tests
      - UI components: verify visually and functionally
      - User-facing stories: MUST verify that a real user can perform the actions described
        in the acceptance criteria through the UI ‚Äî not just via API calls or curl commands
      - The agent decides the testing approach based on what makes sense
    </action>

    <action>Run all existing tests to ensure no regressions</action>
    <action>Run any new tests to verify implementation correctness</action>

    <check if="regression tests fail">
      <action>Fix regressions before proceeding ‚Äî do not leave broken tests</action>
    </check>

    <check if="new tests fail">
      <action>Fix implementation until tests pass ‚Äî do not proceed with failing tests</action>
    </check>

    <action>Document the testing approach:
      - What type of testing was performed (unit tests, visual verification, manual run, etc.)
      - Which test files were created or modified
      - Which ACs each test covers
      This documentation enables the Code Review workflow to efficiently verify test coverage.
    </action>
  </step>

  <step n="8" goal="Verify ALL acceptance criteria are satisfied">
    <critical>Every acceptance criterion must be verified. This is the definition of done.
      Do NOT proceed past this step until every AC is confirmed satisfied.</critical>

    <action>For EACH acceptance criterion, produce a verification entry:
      1. Read the AC text
      2. In your own words, describe what a user would see or experience if this AC is satisfied
         (do NOT reference code constructs ‚Äî describe observable behavior)
      3. Verify against the running application:
         - For interactive behaviors: execute the interaction and capture the result
         - For visual elements: take a screenshot and describe what is visible
         - For data/logic ACs: show test output or API response
         - For infrastructure/code-structural ACs: evidence may reference test output, migration results, or code inspection
      4. Record what you ACTUALLY observed (not what you expected)
      5. Mark: SATISFIED (observation matches expected) or NOT SATISFIED (gap identified)

      Format each entry as:
      AC[N]: [SATISFIED/NOT SATISFIED]
        Expected: [plain-language description of what a user would see]
        Method: [how you verified ‚Äî e.g., screenshot, test runner, API call, code inspection]
        Observed: [what you actually saw in the running app, test output, or inspection]

      CRITICAL: "The hook exists" or "the function is implemented" is NEVER valid as an observation.
      Describe what you SEE, not what you WROTE.
    </action>

    <critical>USER-FACING DELIVERY CHECK: If the story's "As a..." role is an end user,
      verify that every AC can be satisfied by a user interacting with the UI ‚Äî not just by
      calling the API directly. If ACs describe user actions (filling forms, clicking buttons,
      viewing tables) but no UI exists for those actions, the story is NOT done. Build the UI
      before marking complete.</critical>

    <check if="any acceptance criterion is NOT satisfied">
      <action>Go back and fix the implementation until all ACs pass</action>
      <action>Re-run relevant tests after fixes</action>
      <action>If unable to satisfy an AC, HALT and explain what's blocking</action>
    </check>
  </step>

  <step n="9" goal="Platform verification">
    <critical>This step is MANDATORY. Do NOT skip it. Complete all platform checks before proceeding.</critical>

    <!-- LSP Diagnostics ‚Äî use the specific tool -->
    <action>Use the LSP diagnostics tool to check each file that was created or modified during this story.
      Call the LSP diagnostics tool with each file path individually.
      For each file, check for:
      - Type errors or unresolved references introduced by the implementation
      - Unused imports or variables
      - Syntax warnings or deprecated usage
      Set {{lsp_error_count}} to the total errors found across all checked files.
      Set {{lsp_warning_count}} to the total warnings found.
      If LSP reports errors in files changed during this story, fix them before proceeding.
      Warnings should be noted but do not block completion.
    </action>

    <!-- Git Status Verification -->
    <action>Run `git status --porcelain` to verify all implementation changes are tracked.
      Check that:
      - No untracked files that should be committed are missing
      - No unexpected files were modified outside the story's scope
      - The working directory state is clean and documented
      Set {{git_status_clean}} = "yes" if clean, "no" if issues found.
    </action>

    <!-- Visual Verification for UI Stories -->
    <check if="story's 'As a...' role is an end user OR story has UI/UX Deliverables section">
      <action>If the application has a running web server, use the screenshot tool to capture the pages/views
        that were built or modified by this story.
        Navigate to the routes referenced in the acceptance criteria.
        Verify that:
        - The UI elements described in the ACs are visible and properly rendered
        - No visual regressions or broken layouts are apparent
        - The page looks like what a user would expect from the story description
        If screenshots reveal missing or broken UI elements, fix them before proceeding.
        Set {{visual_verification_done}} = "yes" (or "N/A" if not a user-facing story).
      </action>
    </check>
    <check if="story is NOT user-facing">
      <action>Set {{visual_verification_done}} = "N/A"</action>
    </check>
  </step>

  <step n="10" goal="Update story file and sprint status">
    <critical>THIS STEP IS MANDATORY. You MUST update the story file and sprint status.
      Failing to complete this step means the workflow is NOT finished.
      Do NOT skip this step under any circumstances.</critical>

    <action>Update story file Status to "review"</action>
    <action>Set {{story_status_updated}} = "yes"</action>

    <action>Update Dev Agent Record:
      - Agent Model Used
      - Completion Notes: brief summary of what was implemented and key decisions
      - File List: all files created, modified, or deleted (paths relative to repo root)
      - Testing Summary: test approach used, test files created/modified, ACs covered by tests, all tests passing (yes/no)
      - LSP Status: {{lsp_error_count}} errors, {{lsp_warning_count}} warnings
      - Visual Verification: {{visual_verification_done}}
    </action>

    <!-- Update sprint status -->
    <check if="{{sprint_status}} file exists">
      <critical>You MUST update sprint status. This is NOT optional.</critical>
      <action>Load the FULL file: {{sprint_status}}</action>
      <action>Update development_status[{{story_key}}] = "review"</action>
      <action>Save file, preserving ALL comments and structure</action>
      <action>Set {{sprint_status_updated}} = "yes"</action>
    </check>
    <check if="{{sprint_status}} file does NOT exist">
      <action>Set {{sprint_status_updated}} = "N/A"</action>
    </check>

    <!-- Architect review ‚Äî use the specific tool -->
    <action>Use the architect tool (the platform's built-in code review/analysis capability) to review the implementation.
      When calling the architect tool, provide:
      - task: A description requesting evaluation of the story implementation against its acceptance criteria
      - relevant_files: The list of all files created or modified during this story
      - include_git_diff: true
      Incorporate any critical findings before proceeding to Step 11.
      Set {{architect_review_done}} = "yes"
    </action>
  </step>

  <step n="11" goal="Validate completion and communicate results">
    <critical>This is the FINAL step. The workflow is complete ONLY after this step executes AND the completion gate passes.</critical>

    <!-- Completion Validation Gate -->
    <critical>COMPLETION GATE: Before producing the final summary, verify ALL of the following variables are set. If ANY variable is missing, a prior step was skipped ‚Äî go back and complete it NOW.</critical>
    <action>Verify completion:
      1. {{lsp_error_count}} must be set ‚Äî if not, go back to Step 9 and run LSP diagnostics tool
      2. {{git_status_clean}} must be set ‚Äî if not, go back to Step 9 and run git status
      3. {{visual_verification_done}} must be set ‚Äî if not, go back to Step 9
      4. {{story_status_updated}} must equal "yes" ‚Äî if not, go back to Step 10
      5. {{sprint_status_updated}} must be set ‚Äî if not, go back to Step 10
      6. {{architect_review_done}} must equal "yes" ‚Äî if not, go back to Step 10 and run architect tool
    </action>

    <action>Summarize what was implemented: story key, key changes, files modified</action>

    <action>Based on {user_skill_level}, offer to explain:
      - What was implemented and how it works
      - Why certain technical decisions were made
      - How to test or verify the changes
    </action>

    <output>
      **‚úÖ Story Implementation Complete**

      **Story:** {{story_key}}
      **Status:** review

      **Completion Verification:**
      - LSP Diagnostics: {{lsp_error_count}} errors, {{lsp_warning_count}} warnings
      - Git Status: {{git_status_clean}}
      - Visual Verification: {{visual_verification_done}}
      - Story Status Updated: {{story_status_updated}}
      - Sprint Status Updated: {{sprint_status_updated}}
      - Architect Review: {{architect_review_done}}

      **Recommended Next Steps:**
      1. **Start a fresh chat** and say **"code review"** ‚Äî a fresh perspective catches what the implementer missed
      2. In that review session: run **"party mode"** on the findings, apply fixes, and close the story
      3. Then **start a fresh chat** and say **"create story"** to begin the next cycle

      üí° *Fresh chat tip: Code review is most effective when the reviewer reads the code cold, without the implementation context biasing its perspective.*
    </output>

    <check if="{{sprint_status}} file exists">
      <action>Mention current sprint progress</action>
    </check>
  </step>

</workflow>
